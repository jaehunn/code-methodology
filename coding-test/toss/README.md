### 개인 정보를 지켜라!

제한 시간: _10초_

_토스의 프론트엔드 개발자 김토스는 토스 앱 내에 들어갈 더치페이 기능의 개발을 맡게 되었습니다._

_더치페이 기능은 일정 금액을 다른 사람들과 나누어 지불할 수 있는 기능이며, 사용자는 자신 외에 더치페이를 함께 하는 사람들의 이름을 볼 수 있습니다._

_이때 더치페이 대상자에 자신의 연락처에 등록되지 않은 사용자가 포함되어있다면, 그 사람의 개인정보를 보호하기 위해 이름을 '\*'로 마스킹하여 가려주어야 합니다._

_단 이름의 전부를 가려주는 것은 아니고, 앞의 2글자는 원래 이름을 보여주되 그 이후의 글자는 전부 '\*'로 마스킹을 해야 합니다._

_마스킹 처리를 위한 getMaskedName을 구현하세요._

**입력 형식**

1. 함수 getMaskedName의 첫 번째 인자로 마스킹할 이름이 주어집니다.
2. 마스킹할 이름은 string 타입으로, 3 이상 50 이하의 길이를 가집니다. 이름은 한글 또는 알파벳, 공백으로만 이루어져 있다고 가정합니다.

**입출력 예시**

입력

문토스

선우서연

제갈도건

KIMTOSU

김수한무거북이와두루미삼천갑자동방삭

출력

문토\*

선우\*\*

제갈\*\*

KI\*\*\*\*

김수**\*\***\*\*\*\***\*\***

---

### 더치페이에서 돈 나누기

제한 시간: 10초

토스의 프론트엔드 개발자 A는 토스 앱에서 더치페이 기능을 구현하고 있는 상황.

그러나 개발 중, 더치페이 금액을 정확히 n등분할 수 없는 경우가 있다는 것을 알게 되었습니다. 예를 들어 4원을 3명이서 나누려고 하면 1원이 남아버리는 경우를 발견하였습니다.

사일로와 상의한 결과, 남는 ‘자투리 금액’은 모두 더치페이를 만드는 사람이 부담하는 방향으로 제품을 구현하기로 하였으며 프론트엔드 개발자 A는 이 로직을 JavaScript 함수로 옮겨야 합니다.

나눌 금액과 사람의 수가 주어지면 더치페이할 금액을 계산해주는 함수를 구현해주세요.

**입력 형식**

1. splitDutchPayAmount 함수의 첫 번째 인자로 금액을 나누는 사람들의 수 peopleCount, 두 번째 인자로 나누고자 하는 금액 amount가 주어집니다.
2. peopleCount는 1 이상 100 이하의 정수입니다.
3. amount는 1 이상 2,000,000 미만의 정수입니다.
4. amount는 peopleCount보다 언제나 큰 값으로 주어집니다. 즉, amount peopleCount 입니다.

**출력 형식**

1. splitDutchPayAmount 함수는 각 사람이 부담해야 하는 금액을 담은 배열을 반환해야 합니다. 첫 번째 사람을 더치페이를 만든 사람으로 가정합니다.

- splitDutchPayAmount 함수의 이름을 변경하지 마세요.

입력

{"peopleCount":2,"amount":2}

{"peopleCount":3,"amount":4}

{"peopleCount":10,"amount":13500}

{"peopleCount":4,"amount":11003}

{"peopleCount":3,"amount":9850}

출력

[1,1]

[2,1,1]

[1350,1350,1350,1350,1350,1350,1350,1350,1350,1350]

[2753,2750,2750,2750]

[3284,3283,3283]

---

### 숫자에 1000 단위로 콤마(,) 찍기

제한 시간: 10초

토스의 프론트엔드 개발자 한토스는 토스를 통해 받은 혜택들을 정리해서 리포트 형식으로 보여주는 프로젝트를 담당하게 되었습니다. 혜택으로 받은 금액의 총합을 좀 더 보기 쉽도록 천 단위로 콤마(,)를 찍으려고 합니다.

주어지는 입력값에 천 단위로 콤마(comma)를 찍는 함수를 구현하십시오.

**입력 형식**

1. commaizeNumber 함수의 첫 번째 인자로 콤마를 찍을 숫자 num이 주어집니다. 함수 이름을 변경하지 마세요.
2. num은 0 이상 1,000,000,000 미만의 정수로 주어집니다.

**출력 형식**

1. commaizeNumber 함수는 입력된 숫자에 1,000 단위로 콤마(,)를 찍은 문자열을 반환해야 합니다.

입력

1

1234

1234567

출력

1

1,234

1,234,567

---

### 숫자를 한국어로 바꾸기

제한 시간: 10초

토스의 프론트엔드 개발자 박토스는 토스 앱에서 2020년 상반기 동안 사용자가 토스를 통해 송금한 총 금액을 요약해서 웹 서비스를 만들고 있습니다.

그러던 중 함께 일하는 프로덕트 디자이너에게 숫자를 한국어로 표시하면 좋겠다는 의견을 듣게 되었습니다.

"토스를 통해 송금한 금액이 1,000,000원이면 100만원으로 사용자에게 표시하면 더 가독성이 좋을 것 같다."

박토스는 숫자를 한국어로 바꾸는 함수를 토스 프론트엔드 개발자들이 함께 사용할 수 있는 공용 라이브러리에 추가하면 편리하겠다고 생각하여, 일반적인 형태로 이 함수를 개발하고자 합니다.

**입력 형식**

1. formatToKoreanNumber 함수의 첫 번째 인자로 한국어로 바꿀 숫자 num이 주어집니다. 함수 이름을 변경하지 마세요.
2. num은 0 이상 1조(1000000000000) 미만의 정수로 주어집니다.

**출력 형식**

1. formatToKoreanNumber 함수는 입력된 숫자를 한국어로 바꾼 문자열을 반환해야 합니다.
2. 천만(10000000)과 같은 숫자는 1,000만과 같이 천 단위로 콤마를 찍어야 합니다.

백, 십, 일 단위는 한국어로 출력하지 않습니다. 백만(1000000)은 100만, 123은 123으로 출력합니다.

입력

9876543210

123456543210

123

10000

출력

98억7,654만3,210

1,234억5,654만3,210

123

1만

---

### 한국 나이와 만 나이 구하기

제한 시간: 10초

토스의 프론트엔드 개발자 한토스는 사용자에게 맞는 정부지원금을 보여주는 프로젝트를 진행하게 되었습니다. 현재 데이터베이스에는 사용자의 출생년월 데이터만 저장되어 있어서 현재 날짜 기준으로 사용자의 나이를 구하는 함수를 만드려고 합니다.

'만'나이를 기준으로 지급하는 지원금과 '한국 나이'를 기준으로 지급하는 지원금이 섞여있어서 두 경우 모두를 구하는 함수를 만들어야 합니다. 사용자의 생일(출생년월)을 입력으로 받고 만 나이와 한국 나이를 반환하는 함수를 작성하십시오.

**조건**

1. 태어나자마자 한국 나이는 1세가 되고 만 나이는 0세가 된다.
2. 아직 태어나지 않은 경우는 둘다 0세로 처리한다.
3. '한국 나이'는 1월 1일에 나이가 올라가고, '만 나이'는 생일 당일에 올라간다.

**입력 형식**

getAge 함수의 첫번째 인자로 사용자의 생년월일, 두번째 인자로 현재 날짜가 주어집니다.

두 날짜 모두 JavaScript Date 형식으로 주어지고, 유효하지 않은 Date가 주어지는 경우는 없습니다.

**출력 형식**

사용자의 만 나이가 x세, 한국나이가 y세이면 '만 x세, 한국나이 y세' 형식의 문자열을 반환해주세요.

입력

1993-12-2700:00:00,2020-08-3100:00:00

1993-08-0100:00:00,2020-08-3100:00:00

출력

만26세,한국나이28세

만27세,한국나이28세

---

### 남은 시간 계산하기

제한 시간: 10초

토스의 프론트엔드 개발자 한토스는 '에어팟 프로 반짝특가 이벤트' 프로젝트를 담당하게 되었고, 이벤트에 참여하려고 하는 사람들에게 이벤트 종료까지 남은 시간을 보여주는 컴포넌트를 개발하려고 합니다.

현재 시간과 이벤트 종료 시간이 주어지면 현재 시간 기준으로 며칠, 몇 시간, 몇 분, 몇 초가 남았는지 계산하는 함수를 작성하십시오.

**조건**

1. 남은 시간이 남은 시간은 '일' 수로 계산하여 반환한다.
2. 시간을 비교하였을 때, 0시간이 남았지만 아직 1일이 남아있다면 1일 0시 x분 y초로 반환한다. 분, 초 단위에도 동일하게 적용한다.
3. 남은 일수가 없어서 '0일 x시 y분 z초' 인 경우에는 '일' 노출을 제외하고 'x시 y분 z초' 만 반환한다. 시, 분, 초에도 동일하게 적용한다.
4. 전달한 현재 시간이 기준 시간을 지난 경우, 빈 문자열 값을 반환한다.

**입력 형식**

getDistance 함수에 두개의 JavaScript Date 인자가 주어집니다. 첫번째 인자는 현재 시간을 나타내며, 두번째 인자는 이벤트 종료 시간을 나타냅니다. 인자로 주어지는 Date 인자로는 유효한 값만 주어집니다.

**출력 형식**

위 조건에 맞는 문자열을 반환해주세요.

입력

2020-08-2922:58:59,2020-08-3100:00:00

2020-08-3023:58:59,2020-08-3100:00:00

2020-08-3023:00:00,2020-08-3100:00:00

출력

1일1시1분1초

1분1초

1시0분0초

---

### 약속

제한 시간: 2초

토스 프론트엔드 개발자 A는 이번 주의 업무 중 하나를 처리하고 있는데, 사용자가 가지고 있는 토스머니와 토스 포인트를 합친 값을 UI에 표현하려고 합니다.

서버 개발자가 토스머니, 토스 포인트를 반환하는 API를 각각 구현해주었습니다. A는 주어진 API를 활용하여 합계를 구하는 함수를 구현하여야 합니다.

토스머니와 토스 포인트는 0 이상 2,000,000 이하의 정수로 가정합니다.

API를 활용하여 토스머니와 토스 포인트를 가져와 그 합을 구하는 함수를 구현해주세요.

**구현된 함수**

API를 호출하는 함수가 이미 구현되어 있다고 가정합니다.

1. apis.fetchToken: (타입: (userId: number) => Promise<string>) : 첫 번째 인자로 사용자 ID를 받고, 다른 API를 호출하기 위한 토큰을 가져옵니다.
2. apis.fetchTossPoint: (타입: (token: string) => Promise<number>) : 첫 번째 인자로 위에서 가져온 토큰을 받고 사용자의 토스 포인트가 담긴 Promise를 반환합니다.
3. apis.fetchTossMoney: (타입: (token: string) => Promise<number>) : 첫 번째 인자로 위에서 가져온 토큰을 받고 사용자의 토스머니가 담긴 Promise를 반환합니다.

**소요 시간**

각 API가 응답하기까지의 소요 시간을 다음과 같이 가정합니다. API 응답이 이보다 오래 걸리거나 적게 걸리는 경우는 없습니다.

1. apis.fetchToken: 150ms (0.15초)
2. apis.fetchTossPoint: 600ms (0.6초)
3. apis.fetchTossMoney: 600ms (0.6초)

**요구 사항**

1. 주어진 함수를 활용하여 사용자 ID가 주어졌을 때 그 사용자의 토스머니와 토스포인트의 합을 반환하는 fetchTotalAmount 함수를 구현해주세요. fetchTotalAmount 함수는 타입 (userId: number) => Promise<number>를 가져야 합니다.
2. 훌륭한 유저 경험을 위해 로딩 시간을 1초 미만으로 제한합니다.

**예시 데이터**

1. 유저 ID가 1인 사용자는 토스머니 1,000원, 토스포인트 100포인트를 가지고 있습니다.
2. 유저 ID가 2인 사용자는 토스머니 2,000원, 토스포인트 1포인트를 가지고 있습니다.
3. 유저 ID가 3인 사용자는 토스머니 1원, 토스포인트 1,000포인트를 가지고 있습니다.

입력

{"userId":1}

{"userId":2}

{"userId":3}

출력

1100

2001

1001

---

### Assertion 만들기

제한 시간: 10초

토스 프론트엔드 개발자 이토스, 금융업의 엄격한 보안 정책으로 외부 라이브러리를 사용할 수 없는 상황에 처합니다. Assertion 기능을 자체적으로 구현하여 유닛 테스트에 활용하고자 하는데... 애자일 정신을 살려 MVP로 두 가지 기능을 먼저 구현하기로 마음을 먹습니다.

- 위 내용은 이해를 돕기 위한 가상의 상황입니다. 토스팀에선 상황에 적절한 오픈소스 라이브러리를 적극 사용합니다.

**결과 예시**

```jsx
const serviceName = 'dutchPay'
expect(serviceName).toEqual('dutchPay') => { type: 'success' }
expect(serviceName).toEqual('tossPrime') => { type: 'error', message: 'Expected: tossPrime\nReceived: dutchPay' }

const user = { name: '이토스', age: 5 }
expect(user).toEqual({ name: '이토스', age: 5 }) => { type: 'success' }
expect(user).toEqual({ name: '박토스', age: 5 }) => { type: 'error', message: 'Expected: {"name": "박토스","age":5}\nReceived: {"name": "이토스","age":5}' }
expect(user).toBe(user) => { type: 'success' }
expect(user).toBe({ name: '이토스', age: 5 }) => { type: 'error', message: 'Reference is not equal' }
```

**세부 구현 사항**

1. expect 함수를 구현해주십시오. expect 함수는 매개 변수로 검증할 값(received)을 받고, toEqual, toBe 함수를 포함된 객체를 반환합니다.
2. toEqaul, toBe 함수는 매개 변수로 올바른 값(expected)을 받고, expect 함수에서 받은 검증할 값(received)과 비교한 뒤 검증 결과 객체를 반환합니다. toEqual, toBe 함수의 검증 로직은 아래의 결과 예시 섹션을 참고하여 적절히 유추해 구현해주십시오.

**검증 결과 Object는 다음과 같은 프로퍼티를 가집니다.**

1. type: 검증 결과를 나타냅니다. 두 객체가 동일할 경우 success, 그렇지 않으면 error 값을 가집니다.
2. message: 메시지를 나타냅니다. 자세한 내용은 아래 message 템플릿 섹션을 참고해주세요. 👇

**message 템플릿**

1. type 프로퍼티의 값이 error일 경우에만 message가 존재합니다.
2. 템플릿과 일치하지 않으면 테스트 케이스를 통과할 수 없으니 유의해주세요.
3. 단, JSON 형식일 경우 JSON.stringified 함수를 활용하여 포매팅 해주세요.

toEqual:

Expected: {expected}\nReceived: {received}

toBe:

Reference is not equal

입력

{"methodName":"toEqual","received":1,"expected":1}

{"methodName":"toBe","received":{},"expected":{}}

{"methodName":"toEqual","received":{"name":"toss"},"expected":{"name":"toss"}}

{"methodName":"toEqual","received":{"name":"backend"},"expected":{"name":"frontend"}}

출력

{"type":"success"}

{"type":"error","message":"Referenceisnotequal"}

{"type":"success"}

{"type":"error","message":"Expected:{\"name\":\"frontend\"}\nReceived:{\"name\":\"backend\"}"}

---

### History API 구현

제한 시간: 10초

상쾌한 월요일 오전, 토스 프론트엔드 개발자 이토스는 웹 애플리케이션 UI 컴포넌트에 대한 테스트 케이스를 작성하고 있습니다.

그런데 테스트를 작성하고 검증하는 중 컴포넌트 내부에서 Web API - history 객체를 참조하고 있었고, 원하는 테스트가 동작하지 않는 문제가 발생했습니다.

이에 이토스는 굴하지 않고 history mock 객체를 구현하고 주입하려고 합니다.

이토스와 함께 history mock 객체를 만들어보십시오.

1. History interface

(ref: https://developer.mozilla.org/ko/docs/Web/API/History)

2. History.length (readonly)

현재 페이지를 포함해, 세션 기록의 길이를 나타내는 정수를 반환합니다.

3. History.scrollRestoration

기록 탐색 시 스크롤 위치 복원 여부를 명시할 수 있습니다. 가능한 값은 auto와 manual입니다.

4. History.state (readonly)

기록 스택 최상단의 스테이트를 나타내는 값을 반환합니다. popstate 이벤트를 기다리지 않고 현재 기록의 스테이트를 볼 수 있는 방법입니다.

5. History.back()

세션 기록의 바로 뒤 페이지로 이동하는 비동기 메서드입니다.

6. History.forward()

세션 기록의 바로 앞 페이지로 이동하는 비동기 메서드입니다.

7. History.go([delta])

현재 페이지를 기준으로, 상대적인 위치에 존재하는 세션 기록 내 페이지로 이동하는 비동기 메서드입니다. 예를 들어, 매개변수로 -1을 제공하면 바로 뒤로, 1을 제공하면 바로 앞으로 이동합니다. 세션 기록의 범위를 벗어나는 값을 제공하면 아무 일도 일어나지 않습니다. 매개변수를 제공하지 않거나, 0을 제공하면 현재 페이지를 다시 불러옵니다.

8. History.pushState(data, title[, url])

주어진 데이터를 지정한 제목(제공한 경우 URL도)으로 세션 기록 스택에 넣습니다. 직렬화 가능한 모든 JavaScript 객체를 데이터로 사용할 수 있습니다. 참고로, Safari를 제외한 모든 브라우저는 title 매개변수를 무시합니다.

9. History.replaceState(data, title[, url])

세션 기록 스택의 제일 최근 항목을 주어진 데이터, 지정한 제목 및 URL로 대체합니다. 직렬화 가능한 모든 JavaScript 객체를 데이터로 사용할 수 있습니다. 참고로, Safari를 제외한 모든 브라우저는 title 매개변수를 무시합니다.

**아래 조건을 만족한다.**

1. History interface를 만족하는 객체를 구현한다.
2. go() / back() / forward() 가 범위를 벗어나면, Exception은 발생하지않고 해당 호출은 무시된다.
3. length / state는 readonly property입니다. getter/setter 등을 활용합니다.

**다음은 구현하지 않아도 된다.**

1. popstate event는 구현하지 않는다.
2. window의 location을 이동시키거나 페이지를 불러오는 등의 작업은 구현하지 않는다.
3. pushState/replaceState의 3번째 인자 url이 Cross-domain인 경우 Exception이 발생해야하지만, 이번 구현에선 따로 처리하지 않는다.

**입출력 설명**

1. createHistory 함수를 구현한다.
2. createHistory 함수는 구현한 history 객체를 반환한다.
3. 입력값으로 테스트케이스 이름을 입력하여 테스트를 수행한다. "tc1" ~ "tc5"
4. 입력과 출력에 대한 코드는 읽기전용으로 제공되며, 따로 수정하지 않는다.
5. 각 출력값은 "SUCCESS tc1" ~ "SUCCESS tc5" 이다.
6. "all" 을 입력하면 tc1~tc5가 모두 수행된다.

입력

tc1

tc2

tc3

tc4

tc5

출력

SUCCESStc1

SUCCESStc2

SUCCESStc3

SUCCESStc4

SUCCESStc5
