/* 
    1. Two Sum

    정수 배열과 타겟이 주어지면, 타겟을 만드는 두 정수의 인덱스를 반환하세요.
    각 정수는 정확히 하나의 답에 의존하며 같은 정수를 중복해 사용할 수 없습니다.

    각 정수는 짝을 이루는 정수가 존재하므로 하나의 정수를 순회하면서 동시에 보수 정수를 찾아낼 수 있습니다.
    보수를 함께 구하고 메모할 수 있다면, 1차원 메모이제이션이 가능합니다.
    메모이제이션의 자료구조로, 값을 힌트로 인덱스를 찾아내는 해쉬테이블을 사용합니다.
*/

/* 
    2. Reverse Integer

    부호있는 32비트 정수가 주어지면, 정수를 반전시키세요.
    (부호는 반전되지 않습니다. / 높은 자리의 0 은 제거됩니다. / 범위를 벗어나면 0 을 리턴해주세요)

    Hacky 하게 네이티브 메서드를 이용하거나 이터레이션으로 한자리씩 연산하는 방법이 있습니다.
    
*/

/* 
    3. Palindrome Number 

    정수가 Palindrome 인지 확인해보세요. Palindrome 은 반전시켜도 같은 모습을 나타냅니다.

    반전시키는 로직이 필요합니다. 이터레이션, 네이티브 메서드를 이용할 수 있습니다.
    기본적으로 실패하는 상황이 존재합니다. 음수, 10의 배수(반전시켰을 때 높은 자리에 0 이 자리잡게 됩니다.)
    반대로 0 에 대해서는 로직에 상관없이 성공합니다.
*/

/* 
    4. Roman to Integer

    로마 숫자의 7가지 기호를 이용해 값을 구해보세요.
    숫자 4 는 IIII 로 표현하지 않고 V(숫자 5) 에서 I 를 앞에 붙여 표현합니다.
    다른 기호에 대해서도 똑같이 적용됩니다. 단, 숫자 3 은 III 으로 표현가능합니다.
    예를 들어, MCMXCIV 는 1000(M) + CM(1000 - 100) + XC(100 - 10) + IV(5 - 1) = 1994 가 됩니다.

    먼저, 기호에 대한 값을 매핑시킨 자료형이 필요합니다.(해쉬 테이블)
    뒤에서부터 순회하면서 바로 앞에 있는 기호가 자신보다 작은지 확인해야합니다.
    작다면 음수 값이 되고 아니면 양수의 값으로 더해집니다.
    
    아이디어를 살펴봅시다. 
    (1) 미리 음수가 되는 기호의 조합을 값과 매칭시켜놓아도 무방합니다. 이때에는 버블(2개씩) 검색합니다.
    (2) 미리 맨 뒤 값을 세팅시키고 순회합니다. 앞으로 등장하는 기호들이 작다면 빼고 크거나 같다면 더합니다.
*/

/* 
    5. Longest Common Prefix

    문자열 배열이 주어집니다. 공통되는 prefix(접두사) 를 구해보세요.
    만약 접두사가 없다면, 공백("") 을 출력합니다.

    특정 문자열의 문자를 순회하면서 다른 문자열의 문자와 일치하는지 확인하는 2차원 순회를 사용합니다.
    만약 일치하지 않는 부분에 대해서 실패합니다. 순회를 모두 마쳤다면 true 를 반환합니다.
*/

/* 
    6. Valid Parentheses

    '(', ')' '[', ']', '{', '}' 6가지의 괄호로 이루어진 문자열이 주어집니다.
    타당한지 검증해보세요. (타당한 괄호란, 열린 괄호에 대해서 같은 유형의 괄호로 닫혀야합니다. 열린 괄호들은 올바르게 닫혀야합니다.)
    가령, {(}) 은 타당하지 않습니다. {}() 또는 {()} 는 타당합니다.

    패턴을 보면 최근 등장한 열린괄호는 닫힌괄호와 함께 상쇄됨을 알 수 있습니다.
    따라서 나중에 들어온 원소가 먼저 나가는 LIFO 스택 자료형을 이용합니다.
    열린 괄호에 대해 Push 하고 닫힌 괄호가 등장하면 같은 유형인지 판단해 맞다면 pop 합니다.
    유형이 같지 않거나 순회를 마치고 스택에 잔여괄호가 있다면 타당하지 않은 Parentheses 입니다.
*/

/* 
    7. Merge Two Sorted Lists

    정렬된 두 정수 리스트가 주어지면 새로운 배열에 두 정수 배열을 정렬된 형태로 합치세요.
    (리스트는 링크드 리스트입니다.)

    새로운 결과 리스트를 만들어내기 때문에 주어지는 두 리스트를 바로 사용해도 괜찮습니다. 
    이터레이션을 이용해서 병합을 수행합니다. 
*/

/* 
    8. Remove Duplicates from Sorted Array

    정렬된 정수 배열이 주어집니다. 중복되는 값이 없도록 만듭니다. (하나만 남깁니다.)
    중복을 제거한 새로운 배열이 생성되면 길이를 리턴합니다. 주어진 배열을 수정해 적용시켜야합니다. (in-place)

    중복되지 않은 원소에 대해 별도의 결과배열 인덱스를 조정합니다.
*/

/* 
    9. Remove Element

    배열과 값이 주어집니다. 값에 해당하는 배열 내 원소를 제거하세요. 주어진 배열 자체를 수정해야하고 
    새로운 배열에 대한 길이를 반환하세요.

    결과 배열 인덱스를 조정하는 방식으로 처리합니다. 주어진 값에 대한 값이 아니면 결과 배열에 담습니다.
    값에 해당하는 원소를 splice(i, 1) 로 처리할 수도 있습니다.
*/

/* 
    10. Implement strStr()

    strStr() 함수를 구현해보세요. strStr() 함수는 두번째 인자로 주어지는 문자열을 찾아냅니다. 
    indexOf() 를 사용하지 않고 구현해보세요.

    두번째 인자로 주어지는 문자열의 첫 머리를 일치시키고 전체를 일치되는지 확인합니다. 
    만약 일치한다면 첫머리 인덱스를 반환하면 됩니다. 첫 머리 순회를 모두 마쳤다면 찾지 못했으므로 -1 을 리턴합니다.
*/
